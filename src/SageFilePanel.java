package sage;

import javax.swing.*;
import javax.swing.tree.*;
import com.borland.jbcl.layout.*;
import java.io.File;
import java.util.ArrayList;
import java.io.BufferedReader;
import java.util.Vector;
import java.io.FileReader;
import java.awt.Dimension;
import java.awt.Insets;

public abstract class SageFilePanel extends JPanel {
  XYLayout xYLayout1 = new XYLayout();
  ParaFileFilter ParaFilter, FamilyFilter, TraitLocusFilter , MarkerLocusFilter, GenomeFilter, IBDFilter,TypeFilter;

  sage_analysis_info Analysis_object;
  IconNode outputF_node;
  IconNode inputF_node;
  DataCollectionModel Datamodel;
  IconNode para_node;
  DefaultTreeModel treeModel;

  JLabel jLabelPara = new JLabel();
  JTextField jTextFieldPara = new JTextField();
  JButton jButtonPara = new JButton();

  JLabel jLabelPed = new JLabel();
  JTextField jTextFieldPed = new JTextField();
  JButton jButtonPed = new JButton();

  JLabel jLabelOutputName = new JLabel();
  JTextField OutputNameField = new JTextField();

  JButton jNextButton = new JButton();

  JFileChooser jFileChooser1 = new JFileChooser();

  volatile boolean stop_proecss = false;
  ImageIcon next_image;
  ImageIcon error_image;

  public SageFilePanel() {
    this.setLayout(xYLayout1);
    this.setSize(500, 545);

    try {
        next_image = new ImageIcon(SageFilePanel.class.getResource("next.png"));
        error_image = new ImageIcon(SageFilePanel.class.getResource("error_marker.png"));
    } catch (Exception ex) {
        ex.printStackTrace();
    }

    ParaFilter = new ParaFileFilter("par", "Parameter File");
    FamilyFilter = new ParaFileFilter("dat", "Pedigree File");
    TraitLocusFilter = new ParaFileFilter("loc", "Trait File");
    MarkerLocusFilter = new ParaFileFilter("loc", "Locus File");
    GenomeFilter = new ParaFileFilter("gen", "Genome File");
    IBDFilter = new ParaFileFilter("ibd", "IBD File");
    TypeFilter = new ParaFileFilter("typ", "Type File");
    treeModel = (DefaultTreeModel) Frame1.mainFrame1.activeinframe.MyTree1.getModel();

    jLabelOutputName.setToolTipText(
        "<html>Specifies the name of the output file generated by this analysis.");
    jLabelOutputName.setText("Name of output file");

    OutputNameField.setToolTipText(
        "<html>Specifies the name of the output file generated by this analysis.");

    jButtonPed.setText("...");
    jButtonPed.setToolTipText(
        "<html>Contains delimited records for each individual including fields for " +
        "<br>identifiers, parents, trait and covariates.");
    jButtonPed.setText("...");
    jLabelPed.setToolTipText(
        "<html>Contains delimited records for each individual including fields for " +
        "<br>identifiers, parents, trait and covariates.");
    jLabelPed.setText("Data file");
    jTextFieldPed.setText("");
    jButtonPara.setEnabled(false);
    jButtonPara.setToolTipText(
        "<html>Specifies the parameters and options with which to perform a particular " +
        "<br>analysis.");
    jButtonPara.setText("...");
    jLabelPara.setToolTipText(
        "<html>Specifies the parameters and options with which to perform a particular " +
        "<br>analysis.");
    jLabelPara.setText("Parameter file");
    jTextFieldPara.setText("");

    jTextFieldPara.setEditable(false);
    jTextFieldPara.setBackground(java.awt.Color.white);
    jTextFieldPed.setEditable(false);
    jTextFieldPed.setBackground(java.awt.Color.white);

    jNextButton.setHorizontalTextPosition(SwingConstants.LEFT);
    jNextButton.setIcon(error_image);
    jNextButton.setMargin(new Insets(2, 2, 2, 2));
    jNextButton.setText("Next");
    jNextButton.setPreferredSize(new Dimension(60, 25));
  }

  abstract void SetPanel2Info(NodeInfo source);

  abstract void insertparafile(NodeInfo source);
  abstract void insertpedigreefile(NodeInfo source);

  void insertlocusfile(NodeInfo source) {
  }

  void inserttraitfile(NodeInfo source) {
  }

  void inserttypefile(NodeInfo source) {
  }

  void insertgenomefile(NodeInfo source) {
  }

  void insertibdfile(NodeInfo source) {
  }


  public IconNode addObject(IconNode childNode,
                            IconNode parentNode,
                            boolean visible) {
    treeModel.insertNodeInto(childNode, parentNode, parentNode.getChildCount());
    childNode.setParent(parentNode);

    if (visible) {
      TreePath p = new TreePath(childNode.getPath());
      Frame1.mainFrame1.activeinframe.MyTree1.scrollPathToVisible(p);
      Frame1.mainFrame1.activeinframe.MyTree1.setSelectionPath(p);
    }

    TreePath p = new TreePath(childNode.getPath());
    Frame1.mainFrame1.activeinframe.MyTree1.scrollPathToVisible(p);
    return childNode;
  }

  void ensureEventThread()
  {
    if(SwingUtilities.isEventDispatchThread())
    {
      return;
    }
    throw new RuntimeException("only the event thread should invoke this method!");
  }

  ArrayList GetMarkerList(DataCollectionModel paranodemodel, File source_file_path, boolean isHeaderExist) throws Exception
  {
      ArrayList headerlist = new ArrayList();
      ArrayList markerlist = new ArrayList();

      String delimiter = paranodemodel.getValue("delimiters_name").toString();

      FileReader fr = new FileReader(source_file_path);
      BufferedReader br = new BufferedReader(fr);
      String header = br.readLine();

      if(isHeaderExist)
      {
            String line_array[] = header.split(delimiter);
            for (int il = 0; il < line_array.length; il++)
                headerlist.add(line_array[il]);
      }
      else
      {
          String format_name = paranodemodel.getValue("format_name").toString();
            String line_array[] = format_name.split(delimiter);
            for (int il = 0; il < line_array.length; il++)
                headerlist.add(line_array[il]);
      }

     Vector ml_start_array  = (Vector)paranodemodel.getValue("MList_Start_array");
     Vector ml_end_array = (Vector)paranodemodel.getValue("MList_End_array");

     int ml_array_size = ml_start_array.size();

     for(int i=0;i<ml_array_size;i++)
     {
         String start = ml_start_array.get(i).toString();
         String end = ml_end_array.get(i).toString();

         boolean add = false;
         for(int j=0;j<headerlist.size();j++)
         {
             String headername = headerlist.get(j).toString().trim();
             if(headername.compareTo(start)==0)
                 add = true;

             if(add)
             {
                 markerlist.add(headername);
             }
             if(headername.compareTo(end)==0)
                 break;
         }
     }

     return markerlist;
  }


  ArrayList GetCovariateList(DataCollectionModel paranodemodel, File source_file_path, boolean isHeaderExist) throws Exception
  {
      ArrayList headerlist = new ArrayList();
      ArrayList covariatelist = new ArrayList();

      String delimiter = paranodemodel.getValue("delimiters_name").toString();

      FileReader fr = new FileReader(source_file_path);
      BufferedReader br = new BufferedReader(fr);
      String header = br.readLine();

      if(isHeaderExist)
      {
            String line_array[] = header.split(delimiter);
            for (int il = 0; il < line_array.length; il++)
                headerlist.add(line_array[il]);
      }
      else
      {
          String format_name = paranodemodel.getValue("format_name").toString();
            String line_array[] = format_name.split(delimiter);
            for (int il = 0; il < line_array.length; il++)
                headerlist.add(line_array[il]);
      }

     Vector cl_start_array  = (Vector)paranodemodel.getValue("CovList_Start_array");
     Vector cl_end_array = (Vector)paranodemodel.getValue("CovList_End_array");

     int cl_array_size = cl_start_array.size();

     for(int i=0;i<cl_array_size;i++)
     {
         String start = cl_start_array.get(i).toString();
         String end = cl_end_array.get(i).toString();

         boolean add = false;
         for(int j=0;j<headerlist.size();j++)
         {
             String headername = headerlist.get(j).toString().trim();
             if(headername.compareTo(start)==0)
                 add = true;

             if(add)
             {
                 covariatelist.add(headername);
             }
             if(headername.compareTo(end)==0)
                 break;
         }
     }

     return covariatelist;
  }
}

